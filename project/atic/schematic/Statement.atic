use atic.schematic.Expression;
use atic.schematic.Context;
use atic.schematic.Member;
use atic.schematic.Atic;
use atic.schematic.tokens.Node;
use atic.schematic.type.Type;

enum Statement {
    Block(BlockStatement);
    Assign(AssignStatement);
    Branch(BranchStatement);
    Declaration(DeclarationStatement);
    Return(ReturnStatement);
    Single(SingleStatement);
    While(WhileStatement);
}

struct BlockStatement {
    list: List<Statement>
}

struct AssignStatement {
    expression: Expression;
    member: Member;
}

struct BranchStatement {
    expression: Expression;
    thenStatement: Statement;
    elseStatement: Statement;
}

struct DeclarationStatement {
    variable: Variable;
    expression: Expression;
}

struct MatchStatement {
    defaultStatement:  Optional<Statement>;
    expression: Expression;
}

struct ReturnStatement {
    expression: Optional<Expression>;
}

struct SingleStatement {
    expression: Expression;
}

struct WhileStatement {
    expression: Expression;
    statement: Statement;
}

fn fromAST(node: Node, context: Context) -> Statement {
    assertType(node,"statement");
    let child_ = child(node);
    let name = child_.name;

    if name == "blockStatement" {
        return Statement.Block(blockFromTree(child_,context));
    } else if name == "definitionStatement" {
        return Statement.Declaration(definitionFromTree(child_,context));
    }


    throw AssertError(name + " is not impl");

}

fn definitionFromTree(node: Node, context: Context) -> DeclarationStatement {
    assertType(node, "definitionStatement");
    let type = getNode(node, "typeOfDefinition");
    let typeName = child(type).record.data;
    let isConst: bool = typeName == "const";

    let nameOfDef = id(node);
    let expr: Expression = exprFromNode(getNode(node, "expression"),context);

    let defType: Node = getNode(node,"typeOfVar");
    if isPresent(defType, "type") {
        let typeNode = getNode(defType, "type");
        //TODO validate
    } else {
        //TODO infer
    }

    let variable: Variable = Variable(nameOfDef, Type.Primitive("test"), Location.Local(), Modifier.Variable());
    if isConst {
        variable.modifier = Modifier.Final();
    }
    return DeclarationStatement(variable, expr);
}

fn blockFromTree(node: Node, context: Context) -> BlockStatement {


    throw NotImplError();
}