use atic.schematic.Expression;
use atic.schematic.Context;
use atic.schematic.Member;
use atic.schematic.Atic;
use atic.schematic.Path;
use atic.schematic.tokens.Node;
use atic.schematic.type.Type;
use atic.schematic.type.TypeSystem;
use atic.schematic.type.StaticTypes;

enum Statement {
    Block(BlockStatement);
    Assign(AssignStatement);
    Branch(BranchStatement);
    Declaration(DeclarationStatement);
    Return(ReturnStatement);
    Single(SingleStatement);
    While(WhileStatement);
}

struct BlockStatement {
    list: List<Statement>
}

struct AssignStatement {
    expression: Expression;
    member: Member;
}

struct BranchStatement {
    expression: Expression;
    thenStatement: Statement;
    elseStatement: Statement;
}

struct DeclarationStatement {
    variable: Variable;
    expression: Expression;
}

struct ReturnStatement {
    expression: Optional<Expression>;
}

struct SingleStatement {
    member: Member;
}

struct WhileStatement {
    expression: Expression;
    statement: Statement;
}

fn statementFromNode(node: Node, context: Context) -> Statement {
    assertType(node,"statement");
    let child_ = child(node);
    let name = child_.name;

    if name == "blockStatement" {
        return Statement.Block(blockFromTree(child_,context));
    } else if name == "definitionStatement" {
        return Statement.Declaration(definitionFromTree(child_,context));
    } else if name == "returnStatement" {
         return Statement.Return(returnFromTree(child_,context));
    } else if name == "branchStatement" {
        return Statement.Branch(branchFromTree(child_, context));
    } else if name == "whileStatement" {
        return Statement.While(whileFromTree(child_, context));
    } else if name == "assignStatement" {
        return Statement.Assign(assignFromTree(child_, context));
    } else if name == "singleExpression" {
        let memberChild = getNode(child_, "member");
        let member = memberFromTree(memberChild, context)
        return Statement.Single(SingleStatement(member));
    }

    throw AssertError(name + " is not impl");
}

fn assignFromTree(node: Node, context: Context) -> AssignStatement {
    assertType(node, "assignStatement");
    let expr = exprFromNode(getNode(node, "expression"),context);
    let member = memberFromTree(getNode(node, "member"),context);
    let foundType = getExprType(expr);
    if !testTypes(member.returnType, foundType, emptyQuery()) {
        throw AssertError("declaration and assign not compatible");
    }
    return AssignStatement(expr, member);
}

fn branchFromTree(node: Node, context: Context) -> BranchStatement {
    assertType(node, "branchStatement");
    let expr = exprFromNode(getNode(node, "expression"),context);
    let typeFound = getExprType(expr);
    let elseStmt = Statement.Block(BlockStatement(newList<Statement>()));
    let elsePart = getNode(node, "endOfBranch");
    let flag = false;
    let matchPart = getNode(node, "matches");
    if typeFound matches Enum(enumImpl) {
        if isPresent(matchPart, "nChain") {
            let chainNode = getNode(matchPart, "nChain");
            let path = newPathNode(chainNode);
            let optionName = path.path;
            let find: Optional<EnumEntry> = findAny(enumImpl.type.members, fn (entry: EnumEntry) -> bool {
                return entry.name == optionName;
            });
            if find matches None() {
                throw AssertError("could not find enum entry for name " + optionName);
            } else matches Some(enumEntry) {
                let names = newList<string>();
                forEach(walk("id", "idList", matchPart), fn (inName: Node) -> void {
                    let name = id(inName);
                    insert(names, name);
                });
                let lookup = createLookupEnum(enumImpl);
                let types = newList<Type>();
                forEach(enumEntry.components, fn (type: Type) -> void {
                    insert(types, substitute(type, lookup));
                });
                if types.size != names.size {
                    throw AssertError("expected " + toString(types.size) + " number of arguments");
                }
                let copyContext = contextCopy(context);

                forEachI(types, fn (type: Type, index: number) -> void {
                    let name: string = getAt(names, index);
                    let variable = Variable(name, type, Location.Match(), Modifier.Final(), Optional.None<Variable>());
                    insert(copyContext.variables, variable);
                });

                let stmt = statementFromNode(getNode(node, "statement"), copyContext);

                if isPresent(elsePart, "elseStatement") {
                    let elseBranch = getNode(elsePart, "elseStatement");
                    let elseMatches = getNode(elseBranch, "matches");
                    if isPresent(elseMatches, "nChain") {
                        let otherChainNode = getNode(elseMatches, "nChain");
                        let otherPath = newPathNode(otherChainNode);
                        let otherOptionName = otherPath.path;
                        let otherFind: Optional<EnumEntry> = findAny(enumImpl.type.members, fn (entry: EnumEntry) -> bool {
                            return entry.name == otherOptionName;
                        });
                        if otherFind matches None() {
                            throw AssertError("could not find else enum entry for name " + optionName);
                        } else matches Some(elseMatch) {

                            if elseMatch.index == enumEntry.index {
                                throw AssertError("else match part matches with if part");
                            } else {
                                let copyContext3 = contextCopy(context);
                                flag = true;

                                let otherNames = newList<string>();
                                forEach(walk("id", "idList", elseMatches), fn (inName: Node) -> void {
                                    let name = id(inName);
                                    insert(otherNames, name);
                                });
                                let otherLookup = createLookupEnum(enumImpl);
                                let otherTypes = newList<Type>();
                                forEach(elseMatch.components, fn (type: Type) -> void {
                                    insert(types, substitute(type, otherLookup));
                                });

                                if otherTypes.size != otherNames.size {
                                    throw AssertError("expected " + toString(types.size) + " number of arguments");
                                }

                                forEachI(otherTypes, fn (type: Type, index: number) -> void {
                                    let name: string = getAt(otherNames, index);
                                    let variable = Variable(name, type, Location.Match(), Modifier.Final(), Optional.None<Variable>());
                                    insert(copyContext.variables, variable);
                                });

                                elseStmt = statementFromNode(getNode(elseBranch, "statement"), copyContext3);
                            }

                        }
                    }
                    if !flag {
                        let copyContext3 = contextCopy(context);
                        elseStmt = statementFromNode(getNode(elseBranch, "statement"), copyContext3);
                        flag = true;
                    }
                }

                return BranchStatement(expr, stmt, elseStmt);
            }
        } else throw AssertError("expected a match expression");
    }
    if !flag {
        let copyContext4 = contextCopy(context);
        let stmt = statementFromNode(getNode(node, "statement"), copyContext4);
    }


    if !testTypes(Type.Primitive("bool"), typeFound , emptyQuery()) {
        throw AssertError("branch just accepts a bool or an enum with a match expression");
    }

    if isPresent(elsePart, "elseStatement") {
        let elseBranch = getNode(elsePart, "elseStatement");
        elseStmt = statementFromNode(getNode(elseBranch, "statement"), context);
    }

    return BranchStatement(expr, stmt, elseStmt);
}

fn whileFromTree(node: Node, context: Context) -> WhileStatement {
    assertType(node, "whileStatement");
    let expr = exprFromNode(getNode(node, "expression"),context);
    let stmt = statementFromNode(getNode(node, "statement"), context);
    return WhileStatement(expr, stmt);
}

fn returnFromTree(node: Node, context: Context) -> ReturnStatement {
    assertType(node, "returnStatement");
    let returnValue = getNode(node, "returnValue")
    let option = Optional.None<Expression>();
    let returnType = Type.Primitive("void");
    if isPresent(returnValue, "expression") {
        let exprNode = getNode(returnValue, "expression");
        let expr = exprFromNode(exprNode,context);
        option = Optional.Some(expr);
        returnType = getExprType(expr);
    }
    assertExprType(context.returnType, returnType, "return not compatible");
    return ReturnStatement(option);
}

fn definitionFromTree(node: Node, context: Context) -> DeclarationStatement {
    assertType(node, "definitionStatement");
    let typeOfDef = getNode(node, "typeOfDefinition");
    let typeName = child(typeOfDef).record.data;
    let isConst: bool = typeName == "const";

    let nameOfDef = id(node);
    let expr: Expression = exprFromNode(getNode(node, "expression"),context);
    let foundType = getExprType(expr);
    let defType: Node = getNode(node,"typeOfVar");
    let typeOfDecl = Type.Primitive("");
    if isPresent(defType, "type") {
        let typeNode = getNode(defType, "type");
        let type = typeFromTree(typeNode, context);
        typeOfDecl = type;
        if !testTypes(type, foundType, emptyQuery()) {
            throw AssertError("declaration not compatible");
        }
    } else {
        typeOfDecl = foundType;
    }

    let variable: Variable = Variable(nameOfDef, typeOfDecl, Location.Local(), Modifier.Variable(), Optional.None<Variable>());
    if isConst {
        variable.modifier = Modifier.Final();
    }
    addVariable(context, variable);
    return DeclarationStatement(variable, expr);
}

fn blockFromTree(node: Node, context: Context) -> BlockStatement {
    assertType(node, "blockStatement");
    let copyContext = contextCopy(context);
    let statements: List<Statement> = newList<Statement>();
    forEach(walk("statement", "statementList", node), fn (ref: Node) -> void {
        insert(statements, statementFromNode(ref, copyContext));
    });
    return BlockStatement(statements);
}