use atic.schematic.Expression;
use atic.schematic.Context;
use atic.schematic.Member;
use atic.schematic.Atic;
use atic.schematic.tokens.Node;
use atic.schematic.type.Type;

enum Statement {
    Block(BlockStatement);
    Assign(AssignStatement);
    Branch(BranchStatement);
    Declaration(DeclarationStatement);
    Return(ReturnStatement);
    Single(SingleStatement);
    While(WhileStatement);
}

struct BlockStatement {
    list: List<Statement>
}

struct AssignStatement {
    expression: Expression;
    member: Member;
}

struct BranchStatement {
    expression: Expression;
    thenStatement: Statement;
    elseStatement: Statement;
}

struct DeclarationStatement {
    variable: Variable;
    expression: Expression;
}

struct MatchStatement {
    defaultStatement:  Optional<Statement>;
    expression: Expression;
}

struct ReturnStatement {
    expression: Optional<Expression>;
}

struct SingleStatement {
    expression: Expression;
}

struct WhileStatement {
    expression: Expression;
    statement: Statement;
}

fn statementFromNode(node: Node, context: Context) -> Statement {
    assertType(node,"statement");
    let child_ = child(node);
    let name = child_.name;

    if name == "blockStatement" {
        return Statement.Block(blockFromTree(child_,context));
    } else if name == "definitionStatement" {
        return Statement.Declaration(definitionFromTree(child_,context));
    } else if name == "returnStatement" {
         return Statement.Return(returnFromTree(child_,context));
    }


    throw AssertError(name + " is not impl");

}
fn returnFromTree(node: Node, context: Context) -> ReturnStatement {
    assertType(node, "returnStatement");
    let returnValue = getNode(node, "returnValue")
    if isPresent(returnValue, "expression") {
        let exprNode = getNode(returnValue, "expression");
        let expr = exprFromNode(exprNode,context);
        //TODO validate
        return ReturnStatement(Optional.Some(expr));
    } else {
        return ReturnStatement(Optional.None<Expression>());
    }
}


fn definitionFromTree(node: Node, context: Context) -> DeclarationStatement {
    assertType(node, "definitionStatement");
    let type = getNode(node, "typeOfDefinition");
    let typeName = child(type).record.data;
    let isConst: bool = typeName == "const";

    let nameOfDef = id(node);
    let expr: Expression = exprFromNode(getNode(node, "expression"),context);

    let defType: Node = getNode(node,"typeOfVar");
    if isPresent(defType, "type") {
        let typeNode = getNode(defType, "type");
        //TODO validate
    } else {
        //TODO infer
    }

    let variable: Variable = Variable(nameOfDef, Type.Primitive("test"), Location.Local(), Modifier.Variable());
    if isConst {
        variable.modifier = Modifier.Final();
    }
    addVariable(context, variable);
    return DeclarationStatement(variable, expr);
}

fn blockFromTree(node: Node, context: Context) -> BlockStatement {
    assertType(node, "blockStatement");
    let copyContext = contextCopy(context);
    let statements: List<Statement> = newList<Statement>();
    forEach(walk("statement", "statementList", node), fn (ref: Node) -> void {
        insert(statements, statementFromNode(ref, copyContext));
    });
    return BlockStatement(statements);
}