use atic.schematic.Path;
use atic.schematic.Atic;
use atic.schematic.type.StaticTypes;
use atic.schematic.tokens.Node;
use atic.schematic.Context;

enum Type {
    Struct(StructImpl);
    Enum(EnumImpl);
    Function(FunctionType);
    Generic(GenericType);
    Array(Type);
    Primitive(string);
}


struct StructImpl {
    type: Struct;
    implementation: List<Type>
}

struct EnumImpl {
    type: Enum;
    implementation: List<Type>
}

struct FunctionType {
    inputs: List<Type>;
    output: Type;
    generics: Generics;
}

struct GenericType {
    index: number;
    name: string;
}


fn typeFromTree(node: Node, context: Context) -> Type {
    assertType(node, "type");
    let child = child(node);
    let name = child.name;
    if name == "classType"  {
        let genericsType: GenericsType = genericsTypeFromNode(getNode(child, "genericsOptionalType"), context);
        let path = newPathNode(getNode(child, "nChain"));
        if path.path == "void" {
            return Type.Primitive("void");
        } else if path.path == "number" {
            return Type.Primitive("number");
        } else if path.path == "bool" {
            return Type.Primitive("bool");
        } else if path.path == "string" {
            return Type.Primitive("string");
        }
        let genericResult = askForGeneric(context, path);
        if genericResult matches Some(generic) {
            return Type.Generic(generic);
        } else {
            let result = askFor(context, path);
            if result matches None() {
                  throw AssertError("cant find anything for " + path.path);
            } else matches Some(search) {
                if search matches Interface(struct_) {
                    return Type.Struct(StructImpl(struct_, genericsType.types));
                } else if search matches Enum(enum_) {
                    return Type.Enum(EnumImpl(enum_, genericsType.types));
                } else {
                    throw AssertError("Path " + path.path + " cant be resolved to a type");
                }
            }
        }
    } else if name == "functionType" {
        let list: List<Type> = typeListFromTree(getNode(child, "typeList"), context);
        let returnType: Type = typeFromTree(getNode(child, "type"), context);
        let generics: Generics = Generics(newList<GenericType>());
        return Type.Function(FunctionType(list, returnType, generics));
    } else if name == "arrayType" {
        return Type.Array(typeFromTree(getNode(child, "type"), context));
    } else  {
        throw AssertError("cant resolve type " + name);
    }
}

fn typeListFromTree(node: Node, context: Context) -> List<Type> {
    assertType(node, "typeList");
    let list = newList<Type>();
    forEach(walk("type", "typeList", node), fn (subNode: Node) -> void  {
        let type: Type = typeFromTree(subNode,context);
        insert(list,type);
    });
    return list;
}

fn substituteStruct(structImpl: StructImpl, lookup: Map<GenericType,Type>) -> StructImpl {
    let list = newList<Type>();
    forEach(structImpl.implementation, fn (implType: Type) -> void {

        if implType matches Struct(subStruct) {
           insert(list, Type.Struct(substituteStruct(subStruct, lookup)));
        } else if implType matches Generic(genericType) {
            let result = get(lookup, genericType);
            if result matches Some(res) {
                insert(list, res);
            } else {
                insert(list, implType);
            }
        } else {
            insert(list, implType);
        }

    });
    return StructImpl(structImpl.type, list);
}


