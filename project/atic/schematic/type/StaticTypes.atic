use atic.schematic.Path;
use atic.schematic.Atic;
use atic.schematic.type.Type;
use atic.schematic.tokens.Node;
use atic.schematic.Statement;
use atic.schematic.Context;

struct Enum {
    path: Path;
    generics: Generics;
    properties: Properties;
    members: List<EnumEntry>;
}

struct EnumEntry {
    name: string;
    components: List<Type>;
}

struct Struct {
    path: Path;
    generics: Generics;
    properties: Properties;
    members: List<BIEntry<string,Type>>;
}

struct StaticFunction {
    path: Path;
    generics: Generics;
    properties: Properties;
    statement: Optional<Statement>;
    inputs: List<Variable>;
    output: Type;
}

struct RichFunction {
    statement: Statement;
    inputs: List<Variable>;
    output: Type;
    captures: List<Variable>;
}

fn richFunctionFromNode(node: Node, context: Context) -> RichFunction {
    assertType(node, "richFunction");
    //TODO test collisions
    let inputs = newList<Variable>();
    let inputVariable = newList<Variable>();
    forEach(walk("declaration", "declarationList", node), fn (input: Node) -> void {
        let name = id(input);
        let typeNode = getNode(input, "type");
        let variable = Variable(name, typeFromTree(typeNode, context), Location.Input(), Modifier.Final(), Optional.None<Variable>());
        insert(inputs, variable);
        insert(inputVariable, variable);
    });
    let returnType = typeFromTree(getNode(node, "type"), context);
    let copyContext = contextCopy(context);

    forEach(context.variables, fn (var: Variable) -> void {
        insert(inputVariable, Variable(var.name, var.type, Location.Closure(), Modifier.Final(), Optional.Some(var)));
    });
    copyContext.variables = inputVariable;

    let statement = statementFromNode(getNode(node, "statement"), copyContext);
    //TODO usages

    return RichFunction(statement, inputs, returnType, newList<Variable>());
}

struct Generics {
    types: List<GenericType>;
}

fn genericsFromNode(node: Node) -> Generics {
    assertType(node,"genericsOptional");
    let list = newList<GenericType>();
    if isPresent(node,"generics") {
        let generics = getNode(node,"generics");
        let counter = Ref(0);
        forEach(walk("id", "idList", generics), fn (generic: Node) -> void  {
            let name = id(generic);
            if doesContainName__(list,name) {
                throw AssertError("collision with " + name);
            }
            insert(list,GenericType(counter.value, name));
            counter.value = counter.value + 1;
        });
    }
    return Generics(list);
}

struct GenericsType {
    types: List<Type>;
}



fn genericsTypeFromNode(node: Node, context: Context) -> GenericsType {
    assertType(node,"genericsOptionalType");
    let list = newList<Type>();
    if isPresent(node,"genericsType") {
        let generics = getNode(node,"genericsType");
        forEach(walk("type", "typeList", generics), fn (generic: Node) -> void  {
            let type: Type = typeFromTree(generic,context);
            insert(list,type);
        });
    }
    return GenericsType(list);
}

fn doesContainName__(list: List<GenericType>, name: string) -> bool {
   let match_ = doesMatchAny(list, fn (type: GenericType) -> bool {
        if type.name == name {
            return true;
        }
        return false;
   });
   return match_;
}

struct Properties {
    isNative: bool;
    isStrict: bool;
    isAsync: bool;
    isException: bool;
}

fn propertiesFromNode(node: Node) -> Properties {
    assertType(node,"properties");
    let property = Properties(false,false,false,false);
    forEach(walk("property", "properties", node), fn (ref: Node) -> void  {
          if isPresent(ref,"native") {
              if property.isNative {
                 throw AssertError("Duplication of \"native\" ");
              }
              property.isNative = true;
          } else if isPresent(ref,"strict") {
               if property.isStrict {
                  throw AssertError("Duplication of \"strict\" ");
               }
               property.isStrict = true;
          } else if isPresent(ref,"async") {
               if property.isAsync {
                  throw AssertError("Duplication of \"async\" ");
               }
               property.isAsync = true;
          } else if isPresent(ref,"exception") {
               if property.isException {
                   throw AssertError("Duplication of \"exception\" ");
               }
               property.isException = true;
          }
    });
    return property;
}
