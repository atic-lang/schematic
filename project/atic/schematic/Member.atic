use atic.schematic.Path;
use atic.schematic.Expression;
use atic.schematic.Context;
use atic.schematic.type.Type;
use atic.schematic.type.StaticTypes;
use atic.schematic.type.TypeSystem;
use atic.schematic.tokens.Tokenizer;
use atic.schematic.tokens.Node;
use atic.schematic.project.Project;
use atic.schematic.Atic;

struct Member {
    type: MemberType;
    returnType: Type;
}

enum MemberType {
    Function(StaticFunction, List<Expression>);
    Initialisation(Struct, List<Expression>);
    Local(Variable, List<Access>);
}

enum Access {
    Array(Type, Expression);
    Call(Type, List<Expression>);
    Member(Type, number);
}

fn memberFromTree(node: Node, context: Context) -> Member {
    assertType(node, "member");
    let startID: string = id(node);
    let contextVar = askForLocal(context, startID);
    let nodeComponents = walk("varTerminal", "memberCompound", node);
    if contextVar matches Some(variable) {
        let compounds = newList<Access>();
        let typeRef = Ref(variable.type);
        if isPresent(node, "memberCompound") {
            forEach(nodeComponents, fn (subNode: Node) -> void {
                let subTerm: Node = child(subNode);
                let subName = subTerm.name;
                if subName == "memberAccess" {
                    let inType: Type = typeRef.value;
                    if inType matches Struct(structImpl) {
                        //TODO implement generics
                        let memberName: string = id(subTerm);
                        let memberReference = Optional.None<Type>();
                        let memberIndex = -1;
                        let list = structImpl.type.members;
                        let i: number = 0;
                        let s: number = list.size;

                        while i < s {
                            let element: BIEntry<string,Type> = getAt(list,i);
                            if element.key == memberName {
                                memberReference = Optional.Some(element.value);
                                memberIndex = i;
                            }
                            i = i + 1;
                        }

                        if memberReference matches None() {
                            throw AssertError("cant find member " + memberName);
                        } else matches Some(member) {
                            let access = Access.Member(member, memberIndex);
                            insert(compounds, access);
                            typeRef.value = member;
                        }

                    } else {
                        throw AssertError("cant access a member from a here");
                    }
                } else if subName == "callAccess" {

                    let genericsType: GenericsType = genericsTypeFromNode(getNode(subTerm, "genericsOptionalType"), context);
                    let exprList = newList<Expression>();
                    forEach(walk("expression", "argList", subTerm), fn (subNode_: Node) -> void {
                        let expr = exprFromNode(subNode_, context);
                        insert(exprList, expr);
                    });

                    let inType: Type = typeRef.value;
                    if inType matches Function(functionType) {
                        if exprList.size != functionType.inputs.size {
                            throw AssertError("incompatible arg size");
                        }
                        let generics = functionType.generics;
                        let query = MatchQuery(generics.types, newMap<GenericType,Type>());

                        if genericsType.types.size != 0 {
                            if genericsType.types.size != generics.types.size {
                                throw AssertError("incompatible generic hint size");
                            }
                            let i: number = 0;
                            let s: number = generics.types.size;
                            while i < s {
                                let a = getAt(genericsType.types,i);
                                let b = getAt(query.toResolve,i);
                                put(query.resolved, b, a);
                                i = i + 1;
                            }
                        }

                        let i: number = 0;
                        let s: number = exprList.size;

                        while i < s {
                            let a: Type = getAt(functionType.inputs,i);
                            let b: Type = getExprType(getAt(exprList,i));
                            if !testTypes(a, b, query) {
                                throw AssertError("incompatible arguments on function call");
                            }
                            i = i + 1;
                        }

                        let output = functionType.output;
                        let lookup = query.resolved;
                        if output matches Struct(structImpl) {
                            output = Type.Struct(substituteStruct(structImpl, lookup));
                        } else if output matches Generic(genericType) {
                            let result = get(lookup, genericType);
                            if result matches Some(res) {
                                output = res;
                            }
                        }

                        let access = Access.Call(output, exprList);
                        insert(compounds, access);
                        typeRef.value = output;

                    } else {
                        throw AssertError("cant call a here");
                    }
                } else if subName == "arrayAccess" {
                    let inType: Type = typeRef.value;
                    if inType matches Array(subType) {
                        let expr = exprFromNode(getNode(subTerm, "expression"), context);
                        let access = Access.Array(subType, expr);
                        insert(compounds, access);
                        typeRef.value = subType;
                    } else {
                        throw AssertError("cant array access a here");
                    }
                }

            });
        }
        return Member(MemberType.Local(variable, compounds), typeRef.value);
    } else {
        let pathOption = askFor(context, Path(startID));
        if pathOption matches None() {
            throw AssertError("cant find " + startID);
        } else matches Some(pathEntry) {
            match pathEntry {
                Function(staticFunction) -> {
                    if nodeComponents.size != 1 {
                        throw AssertError("you have to call the function");
                    }
                    let callNode: Node = child(getAt(nodeComponents, 0));
                    if callNode.name != "callAccess" {
                        throw AssertError("you can only call a function");
                    }

                    let genericsType: GenericsType = genericsTypeFromNode(getNode(callNode, "genericsOptionalType"), context);
                    let exprList = newList<Expression>();
                    forEach(walk("expression", "argList", callNode), fn (subNode_: Node) -> void {
                        let expr = exprFromNode(subNode_, context);
                        insert(exprList, expr);
                    });
                    if exprList.size != staticFunction.inputs.size {
                        throw AssertError("incompatible arg size");
                    }
                    //************************************
                    let generics = staticFunction.generics;
                    let query = MatchQuery(generics.types, newMap<GenericType,Type>());

                    if genericsType.types.size != 0 {
                        if genericsType.types.size != generics.types.size {
                            throw AssertError("incompatible generic hint size");
                        }
                        let i: number = 0;
                        let s: number = generics.types.size;
                        while i < s {
                            let a = getAt(genericsType.types,i);
                            let b = getAt(query.toResolve,i);
                            put(query.resolved, b, a);
                            i = i + 1;
                        }
                    }

                    let i: number = 0;
                    let s: number = exprList.size;

                    while i < s {
                        let a: Variable = getAt(staticFunction.inputs,i);
                        let b: Type = getExprType(getAt(exprList,i));
                        if !testTypes(a.type, b, query) {
                            throw AssertError("incompatible arguments on function call");
                        }
                        i = i + 1;
                    }

                    let output = staticFunction.output;
                    let lookup = query.resolved;
                    if output matches Struct(structImpl) {
                        output = Type.Struct(substituteStruct(structImpl, lookup));
                    } else if output matches Generic(genericType) {
                        let result = get(lookup, genericType);
                        if result matches Some(res) {
                            output = res;
                        }
                    }
                    //***************************************


                    //TODO implement remaining access
                    //TODO generics
                    return Member(MemberType.Function(staticFunction, exprList), output);
                }
                Enum(enum_) -> {
                    //TODO generics
                    throw AssertError("enum not impl");
                }
                Global() -> {
                    throw AssertError("global not impl");
                }
                Interface(struct_) -> {
                    if nodeComponents.size != 1 {
                        throw AssertError("you have to call the struct to make an instance");
                    }
                    let callNode: Node = child(getAt(nodeComponents, 0));
                    if callNode.name != "callAccess" {
                        throw AssertError("you can only instantiate a struct");
                    }

                    let genericsType: GenericsType = genericsTypeFromNode(getNode(callNode, "genericsOptionalType"), context);
                    let exprList = newList<Expression>();
                    forEach(walk("expression", "argList", callNode), fn (subNode_: Node) -> void {
                        let expr = exprFromNode(subNode_, context);
                        insert(exprList, expr);
                    });
                    if exprList.size != struct_.members.size {
                        throw AssertError("incompatible arg size");
                    }
                    let query = emptyQuery();

                    let listA = exprList;
                    let listB = struct_.members;
                    let i: number = 0;
                    let s: number = listA.size;

                    while i < s {
                        let a: Type = getExprType(getAt(listA,i));
                        let b: BIEntry<string, Type> = getAt(listB,i);
                        if !testTypes(a, b.value, query) {
                            throw AssertError("incompatible arguments on initialisation");
                        }
                        i = i + 1;
                    }


                    //TODO implement remaining access
                    //TODO generics
                    let structImpl = StructImpl(struct_, newList<Type>());
                    return Member(MemberType.Initialisation(struct_, exprList), Type.Struct(structImpl));
                }
            }
        }

    }
}

fn MemberType(member: Member, context: Context) -> Result<Type,AticError> {
   // return Result.Ok<Type,AticError>(Type.Primitive(-1));
   throw NotImplError();
}