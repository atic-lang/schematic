use atic.schematic.Path;
use atic.schematic.Expression;
use atic.schematic.Context;
use atic.schematic.type.Type;
use atic.schematic.type.StaticTypes;
use atic.schematic.type.TypeSystem;
use atic.schematic.tokens.Tokenizer;
use atic.schematic.tokens.Node;
use atic.schematic.project.Project;
use atic.schematic.Atic;

struct Member {
    type: MemberType;
    returnType: Type;
}

enum MemberType {
    Function(StaticFunction, List<Expression>);
    Initialisation(Struct, List<Expression>);
    EnumOption(Enum, EnumEntry, List<Expression>);
    Local(Variable, List<Access>);
}

enum Access {
    Array(Type, Expression);
    Call(Type, List<Expression>);
    Member(Type, number);
}

fn memberUsages(member: Member) -> List<Variable> {
    let variables = newList<Variable>();
    match member.type {
        Function(staticFunction, expressions) -> {
            forEach(expressions, fn(expr: Expression) -> void {
                addAll(variables, expressionUsages(expr));
            });
        }
        Initialisation(struct_, expressions) -> {
            forEach(expressions, fn(expr: Expression) -> void {
                addAll(variables, expressionUsages(expr));
            });
        }
        EnumOption(enum_, enumEntry, expressions) -> {
            forEach(expressions, fn(expr: Expression) -> void {
                addAll(variables, expressionUsages(expr));
            });
        }
        Local(variable, accesses) -> {
            insert(variables, variable);
            forEach(accesses, fn(access: Access) -> void {
                match access {
                    Array(Type, expression) -> {
                        addAll(variables, expressionUsages(expression));
                    }
                    Call(Type, expressions) -> {
                        forEach(expressions, fn(expr: Expression) -> void {
                            addAll(variables, expressionUsages(expr));
                        });
                    }
                    Member(Type, number) -> {
                        
                    }
                }
            });
        }
    }

    return variables;
}


fn memberFromTree(node: Node, context: Context) -> Member {
    assertType(node, "member");
    let startID: string = id(node);
    let contextVar = askForLocal(context, startID);
    let nodeComponents = walk("varTerminal", "memberCompound", node);
    if contextVar matches Some(variable) {
        let compounds = newList<Access>();
        let typeRef = Ref(variable.type);
        if isPresent(node, "memberCompound") {
            forEach(nodeComponents, fn (subNode: Node) -> void {
                let subTerm: Node = child(subNode);
                let subName = subTerm.name;
                if subName == "memberAccess" {
                    let inType: Type = typeRef.value;
                    if inType matches Struct(structImpl) {
                        //TODO implement generics
                        let memberName: string = id(subTerm);
                        let memberReference = Optional.None<Type>();
                        let memberIndex = -1;
                        let list = getMembers(structImpl);
                        let i: number = 0;
                        let s: number = list.size;

                        while i < s {
                            let element: BIEntry<string,Type> = getAt(list,i);
                            if element.key == memberName {
                                memberReference = Optional.Some(element.value);
                                memberIndex = i;
                            }
                            i = i + 1;
                        }

                        if memberReference matches None() {
                            throw AssertError("cant find member " + memberName);
                        } else matches Some(member) {
                            let access = Access.Member(member, memberIndex);
                            insert(compounds, access);
                            typeRef.value = member;
                        }
                    } else {
                        throw AssertError("cant access a member from a here");
                    }
                } else if subName == "callAccess" {
                    let inType: Type = typeRef.value;
                    if inType matches Function(functionType) {
                        let call = callAccess(CallableType.Function(functionType), subTerm, context);
                        let access = Access.Call(call.returnType, call.arguments);
                        insert(compounds, access);
                        typeRef.value = call.returnType;
                    } else {
                        throw AssertError("only call a function");
                    }
                } else if subName == "arrayAccess" {
                    let inType: Type = typeRef.value;
                    if inType matches Array(subType) {
                        let expr = exprFromNode(getNode(subTerm, "expression"), context);
                        let access = Access.Array(subType, expr);
                        insert(compounds, access);
                        typeRef.value = subType;
                    } else {
                        throw AssertError("cant array access a here");
                    }
                }

            });
        }
        return Member(MemberType.Local(variable, compounds), typeRef.value);
    } else {
        let pathOption = askFor(context, Path(startID));
        if pathOption matches None() {
            throw AssertError("cant find " + startID);
        } else matches Some(pathEntry) {
            match pathEntry {
                Function(staticFunction) -> {
                    if nodeComponents.size != 1 {
                        throw AssertError("you have to call the function");
                    }
                    let callNode: Node = child(getAt(nodeComponents, 0));
                    if callNode.name != "callAccess" {
                        throw AssertError("you can only call a function");
                    }
                    let argList = newList<Type>();
                    forEach(staticFunction.inputs, fn (var: Variable) -> void {
                        insert(argList, var.type);
                    });
                    let asFunctionType = FunctionType(argList, staticFunction.output, staticFunction.generics);
                    let call = callAccess(CallableType.Function(asFunctionType), callNode, context);
                    //TODO implement remaining access
                    return Member(MemberType.Function(staticFunction, call.arguments), call.returnType);
                }
                Enum(enum_) -> {
                    if nodeComponents.size != 2 {
                        throw AssertError("you have need a member and call");
                    }
                    let enumOption: Node = child(getAt(nodeComponents, 0));
                    let callNode: Node = child(getAt(nodeComponents, 1));
                    if enumOption.name != "memberAccess" {
                        throw AssertError("you need a member here");
                    }
                    if callNode.name != "callAccess" {
                        throw AssertError("you need a call here");
                    }
                    let optionName = id(enumOption);
                    let find = findAny(enum_.members, fn (entry: EnumEntry) -> bool {
                        return entry.name == optionName;
                    });
                    if find matches Some(enumType) {
                        let call = callAccess(CallableType.Enum(enum_, enumType), callNode, context);
                        return Member(MemberType.EnumOption(enum_, enumType, call.arguments), call.returnType);
                    } else {
                        throw AssertError("cant find any option for " + optionName + " in " + enum_.path.path);
                    }
                }
                Global() -> {
                    throw AssertError("global not impl");
                }
                Interface(struct_) -> {
                    if nodeComponents.size != 1 {
                        throw AssertError("you have to call the struct to make an instance");
                    }
                    let callNode: Node = child(getAt(nodeComponents, 0));
                    if callNode.name != "callAccess" {
                        throw AssertError("you can only instantiate a struct");
                    }
                    let call = callAccess(CallableType.Struct(struct_), callNode, context);
                    return Member(MemberType.Initialisation(struct_, call.arguments), call.returnType);
                }
            }
        }

    }
}


enum CallableType {
    Function(FunctionType);
    Struct(Struct);
    Enum(Enum, EnumEntry);
}

struct CallAccess {
    arguments: List<Expression>;
    returnType: Type;
}

fn callAccess(callable: CallableType, node: Node, context: Context) -> CallAccess {
    assertType(node, "callAccess");

    let genericsType: GenericsType = genericsTypeFromNode(getNode(node, "genericsOptionalType"), context);
    let exprList = newList<Expression>();
    forEach(walk("expression", "argList", node), fn (subNode_: Node) -> void {
        let expr = exprFromNode(subNode_, context);
        insert(exprList, expr);
    });

    if callable matches Function(functionType) {
        if exprList.size != functionType.inputs.size {
            throw AssertError("incompatible arg size");
        }
        let generics = functionType.generics;
        let query = MatchQuery(generics.types, newMap<GenericType,Type>());

        if genericsType.types.size != 0 {
            if genericsType.types.size != generics.types.size {
                throw AssertError("incompatible generic hint size");
            }
            let i: number = 0;
            let s: number = generics.types.size;
            while i < s {
                let a = getAt(genericsType.types,i);
                let b = getAt(query.toResolve,i);
                put(query.resolved, b, a);
                i = i + 1;
            }
        }

        let i: number = 0;
        let s: number = exprList.size;

        while i < s {
            let a: Type = getAt(functionType.inputs,i);
            let b: Type = getExprType(getAt(exprList,i));
            if !testTypes(a, b, query) {
                throw AssertError("incompatible arguments on function call");
            }
            i = i + 1;
        }

        if !isFullyResolved(query) {
            throw AssertError("Query not fully solved (function)");
        }

        let lookup = query.resolved;
        let output = substitute(functionType.output, lookup);
        return CallAccess(exprList, output);
    } else if callable matches Struct(struct_) {
        if exprList.size != struct_.members.size {
            throw AssertError("incompatible arg size");
        }
        let generics = struct_.generics;
        let query = MatchQuery(generics.types, newMap<GenericType,Type>());

        if genericsType.types.size != 0 {
            if genericsType.types.size != generics.types.size {
                throw AssertError("incompatible generic hint size");
            }
            let i: number = 0;
            let s: number = generics.types.size;
            while i < s {
                let a = getAt(genericsType.types,i);
                let b = getAt(query.toResolve,i);
                put(query.resolved, b, a);
                i = i + 1;
            }
        }

        let i: number = 0;
        let s: number = exprList.size;

        while i < s {
            let a: Type = getExprType(getAt(exprList,i));
            let b: BIEntry<string, Type> = getAt(struct_.members,i);
            if !testTypes(b.value, a, query) {
                throw AssertError("incompatible arguments on initialisation");
            }
            i = i + 1;
        }

        if !isFullyResolved(query) {
            throw AssertError("Query not fully solved (initialisation)");
        }

        //TODO implement remaining access
        let solvedList = solvedList(query);
        return CallAccess(exprList, Type.Struct(StructImpl(struct_, solvedList)));
    } else if callable matches Enum(enum_, enumEntry) {
        if exprList.size != enumEntry.components.size {
            throw AssertError("incompatible arg size for enums");
        }
        let generics = enum_.generics;
        let query = MatchQuery(generics.types, newMap<GenericType,Type>());

        if genericsType.types.size != 0 {
            if genericsType.types.size != generics.types.size {
                throw AssertError("incompatible generic hint size");
            }
            let i: number = 0;
            let s: number = generics.types.size;
            while i < s {
                let a = getAt(genericsType.types,i);
                let b = getAt(query.toResolve,i);
                put(query.resolved, b, a);
                i = i + 1;
            }
        }

        let i: number = 0;
        let s: number = exprList.size;

        while i < s {
            let a: Type = getExprType(getAt(exprList,i));
            let b: Type = getAt(enumEntry.components,i);
            if !testTypes(b, a, query) {
                throw AssertError("incompatible arguments on initialisation");
            }
            i = i + 1;
        }

        if !isFullyResolved(query) {
            throw AssertError("Query not fully solved (enum)");
        }

        let solvedList = solvedList(query);
        return CallAccess(exprList, Type.Enum(EnumImpl(enum_, solvedList)));
    }
    throw AssertError("not impl for member");
}