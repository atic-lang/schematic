use atic.schematic.Member;
use atic.schematic.type.Type;
use atic.schematic.Context;
use atic.schematic.tokens.Tokenizer;
use atic.schematic.Atic;

enum Expression {
    Bool(BoolExpression);
    Object(Complex);
}

enum BoolExpression {
    Implemented(ComparisonExpression, Operator, BoolExpression);
    Normal(ComparisonExpression);
}

enum ComparisonExpression {
    Implemented(ArithmeticExpression, Operator, ComparisonExpression);
    Normal(ArithmeticExpression);
}

enum ArithmeticExpression {
    Implemented(Term, Operator, ArithmeticExpression);
    Normal(Term);
}

enum Term {
   Implemented(Factor, Operator, Term);
   Normal(Factor);
}

enum Factor {
    Expression(Expression);
    Number(number);
    BoolLiteral(bool);
    Not(Factor);
    NegUnary(Factor);
    Member(Member);
}

struct Complex {

}


fn factorType(factor: Factor, context: Context) -> Result<Type,AticError> {

   // match factor {
   //    Expression(expression) -> return expressionType(expression,context);
   //    Number(_) -> return Result.Ok(number_);
   //    BoolLiteral(_) -> return Result.Ok(bool_);
   //    Not(factor) -> return factorType(factor,context);
   //    NegUnary(factor) -> return factorType(factor,context);
   //    Member(member) -> return MemberType(member, context);
   //}

    return Result.Error<Type,AticError>(AticError(Position(-1,-1,-1),"not impl"));
}

fn expressionType(expression: Expression, context: Context) -> Result<Type,AticError> {
    return Result.Ok<Type,AticError>(Type.Primitive(-1));
}

enum Operator {
    Add();
    Subtract();
    Multiply();
    Divide();
    Or();
    And();
    Greater();
    GreaterEq();
    Smaller();
    SmallerEq();
    Equals();
    NonEquals();
}