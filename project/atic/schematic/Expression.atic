use atic.schematic.Member;
use atic.schematic.type.Type;
use atic.schematic.Context;
use atic.schematic.tokens.Tokenizer;
use atic.schematic.tokens.Node;
use atic.schematic.Atic;

enum Expression {
    Bool(BoolExpression);
    Object(Complex);
}

enum BoolExpression {
    Implemented(ComparisonExpression, Operator, BoolExpression);
    Normal(ComparisonExpression);
}

enum ComparisonExpression {
    Implemented(ArithmeticExpression, Operator, ComparisonExpression);
    Normal(ArithmeticExpression);
}

enum ArithmeticExpression {
    Implemented(Term, Operator, ArithmeticExpression);
    Normal(Term);
}

enum Term {
   Implemented(Factor, Operator, Term);
   Normal(Factor);
}

enum Factor {
    Expression(Expression);
    Number(number);
    BoolLiteral(bool);
    Not(Factor);
    NegUnary(Factor);
    Member(Member);
}

struct Complex {

}


fn exprFromNode(node: Node, context: Context) -> Expression {
    assertType(node,"expression");
    if isPresent(node, "boolArithmetic") {
        let boolExpr = boolFromNode(getNode(node,"boolArithmetic"),context);
        return Expression.Bool(boolExpr);
    }
    throw AssertError("not impl for complex");
}

fn boolFromNode(node: Node, context: Context) -> BoolExpression {
    assertType(node,"boolArithmetic");
    let left = getNode(node,"comparisonArithmetic");
    let expression = compFromTree(left, context);
    let right = getNode(node,"boolRight");

    if isPresent(right, "boolArithmeticFunc") {
        let function = getNode(right,"boolArithmeticFunc");
        let rightElement = boolFromNode(getNode(right, "boolArithmetic"), context);
        return BoolExpression.Implemented(expression, OperatorFromTree(function), rightElement);
    } else {
        return BoolExpression.Normal(expression);
    }
}

fn compFromTree(node: Node, context: Context) -> ComparisonExpression {
    throw AssertError("Comparison not impl");
}

fn factorType(factor: Factor, context: Context) -> Result<Type,AticError> {

   // match factor {
   //    Expression(expression) -> return expressionType(expression,context);
   //    Number(_) -> return Result.Ok(number_);
   //    BoolLiteral(_) -> return Result.Ok(bool_);
   //    Not(factor) -> return factorType(factor,context);
   //    NegUnary(factor) -> return factorType(factor,context);
   //    Member(member) -> return MemberType(member, context);
   //}

    return Result.Error<Type,AticError>(AticError(Position(-1,-1,-1),"not impl"));
}

fn expressionType(expression: Expression, context: Context) -> Result<Type,AticError> {
    //return Result.Ok<Type,AticError>(Type.Primitive(-1));
    throw NotImplError();
}

enum Operator {
    Add();
    Subtract();
    Multiply();
    Divide();
    Or();
    And();
    Greater();
    GreaterEq();
    Smaller();
    SmallerEq();
    Equals();
    NonEquals();
}

fn OperatorFromTree(node: Node) -> Operator {
    let name = child(node).record.data;
    if name == "+" {
        return Operator.Add();
    } else if name == "-" {
        return Operator.Subtract();
    } else if name == "*" {
        return Operator.Multiply();
    } else if name == "/" {
        return Operator.Divide();
    } else if name == "||" {
        return Operator.Or();
    } else if name == "&&" {
        return Operator.And();
    } else if name == ">=" {
        return Operator.GreaterEq();
    } else if name == ">" {
        return Operator.Greater();
    } else if name == "<=" {
        return Operator.SmallerEq();
    } else if name == "<" {
        return Operator.Smaller();
    } else if name == "==" {
        return Operator.Equals();
    } else if name == "!=" {
        return Operator.NonEquals();
    } else {
        throw NotFoundMsgError("cant find " + name + " to match");
    }

}