use atic.schematic.Member;
use atic.schematic.type.Type;
use atic.schematic.Context;
use atic.schematic.tokens.Tokenizer;
use atic.schematic.tokens.Node;
use atic.schematic.Atic;

enum Expression {
    Bool(BoolExpression);
    Object(Complex);
}

enum BoolExpression {
    Implemented(ComparisonExpression, Operator, BoolExpression);
    Normal(ComparisonExpression);
}

enum ComparisonExpression {
    Implemented(ArithmeticExpression, Operator, ComparisonExpression);
    Normal(ArithmeticExpression);
}

enum ArithmeticExpression {
    Implemented(Term, Operator, ArithmeticExpression);
    Normal(Term);
}

enum Term {
   Implemented(Factor, Operator, Term);
   Normal(Factor);
}

enum Factor {
    Expression(Expression);
    Number(number);
    BoolLiteral(bool);
    Not(Factor);
    NegUnary(Factor);
    String(string);
    Member(Member);
}

struct Complex {

}


fn exprFromNode(node: Node, context: Context) -> Expression {
    assertType(node,"expression");
    if isPresent(node, "boolArithmetic") {
        let boolExpr = boolFromNode(getNode(node,"boolArithmetic"),context);
        return Expression.Bool(boolExpr);
    }
    throw AssertError("not impl for complex");
}

fn boolFromNode(node: Node, context: Context) -> BoolExpression {
    assertType(node,"boolArithmetic");
    let left = getNode(node,"comparisonArithmetic");
    let expression = compFromTree(left, context);
    let right = getNode(node,"boolRight");

    if isPresent(right, "boolArithmeticFunc") {
        let function = getNode(right,"boolArithmeticFunc");
        let rightElement = boolFromNode(getNode(right, "boolArithmetic"), context);
        return BoolExpression.Implemented(expression, OperatorFromTree(function), rightElement);
    } else {
        return BoolExpression.Normal(expression);
    }
}

fn compFromTree(node: Node, context: Context) -> ComparisonExpression {
    assertType(node,"comparisonArithmetic");
    let left = getNode(node,"arithmetic");
    let expression = arithmeticFromNode(left, context);
    let right = getNode(node,"comparisonRight");

    if isPresent(right, "comparisonArithmeticFunc") {
        let function = getNode(right,"comparisonArithmeticFunc");
        let rightElement = compFromTree(getNode(right, "comparisonArithmetic"), context);
        return ComparisonExpression.Implemented(expression, OperatorFromTree(function), rightElement);
    } else {
        return ComparisonExpression.Normal(expression);
    }
}

fn arithmeticFromNode(node: Node, context: Context) -> ArithmeticExpression {
    assertType(node,"arithmetic");
    let left = getNode(node,"term");
    let expression = termFromTree(left, context);
    let right = getNode(node,"arithmeticRight");

    if isPresent(right, "arithmeticFunc") {
        let function = getNode(right,"arithmeticFunc");
        let rightElement = arithmeticFromNode(getNode(right, "arithmetic"), context);
        return ArithmeticExpression.Implemented(expression, OperatorFromTree(function), rightElement);
    } else {
        return ArithmeticExpression.Normal(expression);
    }
}

fn termFromTree(node: Node, context: Context) -> Term {
    assertType(node,"term");
    let left = getNode(node,"factor");
    let expression = factorFromTree(left, context);
    let right = getNode(node,"termRight");

    if isPresent(right, "termFunc") {
        let function = getNode(right,"termFunc");
        let rightElement = termFromTree(getNode(right, "term"), context);
        return Term.Implemented(expression, OperatorFromTree(function), rightElement);
    } else {
        return Term.Normal(expression);
    }
}

fn factorFromTree(node: Node, context: Context) -> Factor {
    if isPresent(node, "number") {
        return Factor.Number(0);
    } else if isPresent(node, "boolArithmetic") {
        let expr = getNode(node, "boolArithmetic");
        return Factor.Expression(Expression.Bool(boolFromNode(expr, context)));
    } else if isPresent(node, "unary") {
        let expr = getNode(node, "unary");
        return Factor.NegUnary(factorFromTree(getNode(expr, "factor"), context));
    } else if isPresent(node, "string") {
        let expr = getNode(node, "string");
        let str: string = child(expr).record.data;
        let subStr = substring2(str, 1, length(str) - 1);
        return Factor.String(subStr);
    }  else if isPresent(node, "boolLiteral") {
        let expr = getNode(node, "boolLiteral");
        let str: string = child(expr).record.data;
        let boolean = false;
        if str == "true" {
            boolean = true;
        } else if str != "false" {
            throw AssertError("cant resolve " + str);
        }
        return Factor.BoolLiteral(boolean);
    } else if isPresent(node, "not") {
        let expr = getNode(node, "not");
        return Factor.Not(factorFromTree(getNode(expr, "factor"), context));
    } else if isPresent(node, "member") {
       let expr = getNode(node, "member");
       return Factor.Member(memberFromTree(expr, context));
    } else {
        let typeN = child(node).name;
        throw AssertError(typeN + " is not impl");
    }
}


fn getExprType(expression: Expression) -> Type {
    if expression matches Bool(boolExpr) {
        return getBoolExprType(boolExpr);
    }
    throw NotImplError();
}

fn getBoolExprType(expr: BoolExpression) -> Type {
    if expr matches Implemented(a,b,c) {
        return getCompExprType(a);
    } else matches Normal(a) {
        return getCompExprType(a);
    }
}
fn getCompExprType(expr: ComparisonExpression) -> Type {
    if expr matches Implemented(a,b,c) {
        return getAriExprType(a);
    } else matches Normal(a) {
        return getAriExprType(a);
    }
}

fn getAriExprType(expr: ArithmeticExpression) -> Type {
    if expr matches Implemented(a,b,c) {
        return getTermType(a);
    } else matches Normal(a) {
        return getTermType(a);
    }
}

fn getTermType(expr: Term) -> Type {
    if expr matches Implemented(a,b,c) {
        return getFactorType(a);
    } else matches Normal(a) {
        return getFactorType(a);
    }
}

fn getFactorType(expr: Factor) -> Type {
    match expr {
        Expression(expression) -> {
            return getExprType(expression);
        }
        Number(_) -> {
            return Type.Primitive("number");
        }
        BoolLiteral(_) -> {
            return Type.Primitive("bool");
        }
        Not(factor) -> {
            return getFactorType(factor);
        }
        NegUnary(factor) -> {
            return getFactorType(factor);
        }
        String(_) -> {
            return Type.Primitive("string");
        }
        Member(member) -> {
            return member.returnType;
        }
    }
}


enum Operator {
    Add();
    Subtract();
    Multiply();
    Divide();
    Or();
    And();
    Greater();
    GreaterEq();
    Smaller();
    SmallerEq();
    Equals();
    NonEquals();
}

fn OperatorFromTree(node: Node) -> Operator {
    let name = child(node).record.data;
    if name == "+" {
        return Operator.Add();
    } else if name == "-" {
        return Operator.Subtract();
    } else if name == "*" {
        return Operator.Multiply();
    } else if name == "/" {
        return Operator.Divide();
    } else if name == "||" {
        return Operator.Or();
    } else if name == "&&" {
        return Operator.And();
    } else if name == ">=" {
        return Operator.GreaterEq();
    } else if name == ">" {
        return Operator.Greater();
    } else if name == "<=" {
        return Operator.SmallerEq();
    } else if name == "<" {
        return Operator.Smaller();
    } else if name == "==" {
        return Operator.Equals();
    } else if name == "!=" {
        return Operator.NonEquals();
    } else {
        throw NotFoundMsgError("cant find " + name + " to match");
    }

}