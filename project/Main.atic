use atic.schematic.project.Project;
use atic.schematic.Path;
use atic.schematic.Atic;
use atic.schematic.tokens.Node;
use atic.schematic.tokens.Tokenizer;
use atic.schematic.type.StaticTypes;
use atic.schematic.type.Type;
use atic.schematic.lexer.GrammarReader;
use atic.schematic.lexer.Lexer;
use atic.schematic.Context;
use atic.schematic.Statement;


fn Main() {
    let project: Project = Project(
        newMap<string,PathEntry>(),
        "res/res2",
        newList<Unit>(),
        ["atic"]
    );
    let src: string = loadFile("res/res2/testGrammar.txt");
    let ruleSet = generateRuleSet(split(src,"\n"));
    src = "";
    compileProject(project,ruleSet);
}

fn compileProject(project: Project, rules: RuleSet) {
    let files: List<string> = newList<string>();
    forFile(project.file,files);

    let units: List<Unit> = newList<Unit>();
    forEach(files, fn (ref: string) -> void {
        project;
        if containsArray(project.extensions, getExtension(ref)) {
            let src: string = loadFile(ref);
            let path: Path = pathFromFiles(ref, project.file);
            let unit: Unit = Unit(
                path,
                src,
                Optional.None<Node>(),
                Optional.None<Environment>(),
                newMap<Struct,Node>(),
                newMap<StaticFunction,Node>()
            );

            insert(units, unit);
        } else {
            print("Dont include " + ref);
        }
    });

    let tokenList: List<Token> = genTokenList();

    forEach(units, fn (ref: Unit) -> void {
        lexUnit(project, ref, tokenList, rules);
    });

    forEach(units, fn (ref: Unit) -> void {
        resolveMembers(project, ref);
    });

    forEach(units, fn (ref: Unit) -> void {
        resolveFunctionHead(project, ref);
    });

    forEach(units, fn (ref: Unit) -> void {
       resolveFunctionBody(project, ref);
    });

    forEach(units, fn (ref: Unit) -> void {
        forEachBI(ref.interfaces, fn (struct_: Struct, node: Node) -> void {
            //print(struct_.path.path + ":");
            forEach(struct_.members, fn (entry: BIEntry<string, Type>) -> void {
                //print(name);
            });
        });
    });
}

fn lexUnit(project: Project, unit: Unit, tokenList: List<Token>, rules: RuleSet) {
    print("lexing " + unit.path.path);
    let node: Node = generateNode(unit.src, tokenList, rules);
    unit.node = Optional.Some(node);
    let environment = Environment(unit.path, project, newList<Path>());
    unit.environment = Optional.Some(environment);

    let list: List<Node> = walk("top", "topList", node);
    forEach(list, fn (n: Node) -> void {
        if isPresent(n, "struct") {
             let struct_ = getNode(n,"struct");
             let name = id(struct_);
             let path = pathAddStr(environment.path, name);
             let structObj = Struct(
                 path,
                 genericsFromNode(getNode(struct_, "genericsOptional")),
                 propertiesFromNode(getNode(struct_, "properties")),
                 newList<BIEntry<string,Type>>()
             );
             put(project.entries, path.path, PathEntry.Interface(structObj));
             put(unit.interfaces, structObj, struct_);
        } else if isPresent(n, "import") {
             let import_ = getNode(n, "import");
             let path = newPathNode(getNode(import_, "nChain"));
             insert(environment.imports,path);
        }
    });
}

fn resolveMembers(project: Project, unit: Unit) {
    if unit.environment matches Some(environment) {
        forEachBI(unit.interfaces, fn (struct_: Struct, node: Node) -> void {
            let list: List<BIEntry<string,Type>> = struct_.members;
            let definitions = getNode(node, "structDefinitionList")
            let context = Context(environment, newList<Variable>(), struct_.generics,  Type.Primitive("void"));
            forEach(walk("structDefinition", "structDefinitionList", definitions), fn (sNode: Node) -> void {
                let name: string = id(sNode);
                let typeNode: Node = getNode(sNode,"type");
                let biEntry = BIEntry(name, typeFromTree(typeNode, context));
                insert(list, biEntry);
            });
        });
    }
}

fn resolveFunctionHead(project: Project, unit: Unit) {
    if unit.environment matches Some(environment) {
        if unit.node matches Some(node) {
         let list: List<Node> = walk("top", "topList", node);
         forEach(list, fn (n: Node) -> void {
             if isPresent(n, "topFunction") {
                let functionNode = getNode(n,"topFunction");

                let name = id(functionNode);
                let generics = genericsFromNode(getNode(functionNode, "genericsOptional"));
                let properties = propertiesFromNode(getNode(functionNode, "properties"));
                let path = pathAddStr(unit.path, name);
                let fContext: Context = Context(
                    environment,
                    newList<Variable>(),
                    generics,
                    Type.Primitive("void")
                );

                let returnNode: Node = getNode(functionNode,"returnType");
                let returnType: Type = Type.Primitive("void");
                if isPresent(returnNode, "type") {
                    returnType = typeFromTree(getNode(returnNode, "type"), fContext);
                }

                let inputs = newList<Variable>();
                forEach(walk("declaration", "declarationList", functionNode), fn (inNode: Node) -> void {
                    let inputName = id(inNode);
                    let type = getNode(inNode, "type");
                    let returnType_ = typeFromTree(type, fContext);
                    let variable: Variable = Variable(inputName, returnType_, Location.Input(), Modifier.Final());
                    insert(inputs, variable);
                });
                let staticFunction: StaticFunction = StaticFunction(path, generics, properties, Optional.None<Statement>(), inputs, returnType);
                put(project.entries, path.path, PathEntry.Function(staticFunction));
                put(unit.functions, staticFunction, getNode(functionNode,"blockStatement"));
             }
         });
        }
    }
}


fn resolveFunctionBody(project: Project, unit: Unit) {
    if unit.environment matches Some(environment) {
        forEachBI(unit.functions, fn (function: StaticFunction, node: Node) -> void {
            let list: List<Variable> = newList<Variable>();
            addAll(list,function.inputs);
            let context = Context(environment, list, function.generics, function.output);
            let statement = blockFromTree(node, context);
        });
    }
}

fn generateNode(src: string, tokens: List<Token>, rules: RuleSet) -> Node {
    let list: List<TokenRecord> = newList<TokenRecord>();

    let lineCount: Ref<number> = Ref(0);
    forEach(split(src,"\n"), fn (line: string) -> void {
        let result: List<TokenRecord> = generateTokens(tokens,line,lineCount.value);
        lineCount.value = lineCount.value + 1;
        addAll(list,result);
    });

    let filtered: List<TokenRecord> = filter(list, fn (token: TokenRecord) -> bool {
         if token.token.alias == "#comment" return false;
         else if token.token.alias == "#whitespace" return false;
         else return true;
    });

    /*
    forEach(filtered, fn (rec: TokenRecord) -> void {
        print(rec.token.alias);
        print(rec.data);
        print("");
    });
    */


    let node: Node = reverseRule(rules,"entry",filtered);
    return node;
}

fn forFile(file: string, list: List<string>) {
    if isDirectory(file) {
        let files: List<string> = listFiles(file);
        forEach(files,fn (ref: string) -> void {
            forFile(ref,list);
        });
    } else {
        insert(list,file);
    }
}

fn genTokenList() -> List<Token> {
    let list: List<Token> = newList<Token>();

    let A_comment: Token = genToken("#comment", "\\/\\/", "\\/\\/.*");
    let A_whitespace: Token = genToken("#whitespace", "\\s", "\\s*");
    let A_assign_arrow: Token = genToken("->", "->", "(-|->)");
    let A_parentheses_o: Token = genToken("(", "\\(", "\\(");
    let A_parentheses_c: Token = genToken(")", "\\)", "\\)");
    let A_braces_o: Token = genToken("{", "\\{", "\\{");
    let A_braces_c: Token = genToken("}", "\\}", "\\}");
    let A_bracket_o: Token = genToken("[", "\\[", "\\[");
    let A_bracket_c: Token = genToken("]", "\\]", "\\]");
    let A_separator: Token = genToken(",", "\\,", "\\,");
    let A_non_equals: Token = genToken("!=", "!=", "(!=|!)");
    let A_equals: Token = genToken("==", "==", "(==|=)");
    let A_smaller_equals: Token = genToken("<=", "<=", "(<=|<)");
    let A_greater_equals: Token = genToken(">=", ">=", "(>=|>)");
    let A_or: Token = genToken("||", "\\|\\|", "(\\||\\|\\|)");
    let A_and: Token = genToken("&&", "\\&\\&", "(\\&|\\&\\&)");
    let A_not: Token = genToken("!", "\\!", "\\!");
    let A_plus: Token = genToken("+", "\\+", "(\\+)");
    let A_minus: Token = genToken("-", "\\-", "(\\-)");
    let A_mul: Token = genToken("*", "\\*", "(\\*)");
    let A_div: Token = genToken("/", "\\/", "(\\/)");
    let A_greater: Token = genToken("<", "<", "(<)");
    let A_smaller: Token = genToken(">", ">", "(>)");
    let A_string: Token = genToken("string", "\"", "");
    let A_function: Token = genToken("fn", "fn\\b", "(fn|f)");
    let A_list: Token = genToken("lst", "lst\\b", "(l|ls|lst)");
    let A_let: Token = genToken("let", "let\\b", "(let|le|l)");
    let A_use: Token = genToken("use", "use\\b", "(use|us|e)");
    let A_if: Token = genToken("if", "if\\b", "(if|i)");
    let A_else: Token = genToken("else", "else\\b", "(else|els|el|e)");
    let A_const: Token = genToken("const", "const\\b", "(const|cons|con|co|c)");
    let A_while: Token = genToken("while", "while\\b", "(while|whil|whi|wh|w)");
    let A_enum: Token = genToken("enum", "enum\\b", "(enum|enu|en|e)");
    let A_match: Token = genToken("match", "match\\b", "(match|matc|mat|ma|m)");
    let A_matches: Token = genToken("matches", "matches\\b", "(matches|matche|match|matc|mat|ma|m)");
    let A_global: Token = genToken("global", "global\\b", "(global|globa|glob|glo|gl|g)");
    let A_true: Token = genToken("true", "true\\b", "(true|tru|tr|t)");
    let A_false: Token = genToken("false", "false\\b", "(false|fals|fal|fa|f)");
    let A_logic: Token = genToken("logic", "logic\\b", "(logic|logi|log|lo|l)");
    let A_native: Token = genToken("native", "native\\b", "(native|nativ|nati|nat|na|n)");
    let A_strict: Token = genToken("strict", "strict\\b", "(strict|stric|stri|str|st|s)");
    let A_exception: Token = genToken("exception", "exception\\b", "(exception|exceptio|excepti|except|excep|exce|exc|ex|e)");
    let A_async: Token = genToken("async", "async\\b", "(async|asyn|asy|as|a)");
    let A_struct: Token = genToken("struct", "struct\\b", "(struct|struc|stru|str|st|s)");
    let A_return: Token = genToken("return", "return\\b", "(return|retur|retu|ret|re|r)");
    let A_throw: Token = genToken("throw", "throw\\b", "(throw|thro|thr|th|t)");
    let A_number: Token = genToken("number", "[0-9]", "[0-9\\.]+");
    let A_keyword: Token = genToken("keyword", "\\w", "\\w+");
    let A_colon: Token = genToken(":", ":", ":");
    let A_semicolon: Token = genToken(";", ";", ";");
    let A_dot: Token = genToken(".", "\\.", "\\.");
    let A_assign: Token = genToken("=", "=", "=");
    let A_end_of_file: Token = genToken("EOF", "$a^", "$a^");
    insert(list, A_comment);
    insert(list, A_whitespace);
    insert(list, A_assign_arrow);
    insert(list, A_parentheses_o);
    insert(list, A_parentheses_c);
    insert(list, A_braces_o);
    insert(list, A_braces_c);
    insert(list, A_bracket_o);
    insert(list, A_bracket_c);
    insert(list, A_separator);
    insert(list, A_non_equals);
    insert(list, A_equals);
    insert(list, A_smaller_equals);
    insert(list, A_greater_equals);
    insert(list, A_or);
    insert(list, A_and);
    insert(list, A_not);
    insert(list, A_plus);
    insert(list, A_minus);
    insert(list, A_mul);
    insert(list, A_div);
    insert(list, A_greater);
    insert(list, A_smaller);
    insert(list, A_string);
    insert(list, A_function);
    insert(list, A_list);
    insert(list, A_let);
    insert(list, A_use);
    insert(list, A_if);
    insert(list, A_else);
    insert(list, A_const);
    insert(list, A_while);
    insert(list, A_enum);
    insert(list, A_match);
    insert(list, A_matches);
    insert(list, A_global);
    insert(list, A_true);
    insert(list, A_false);
    insert(list, A_logic);
    insert(list, A_native);
    insert(list, A_strict);
    insert(list, A_exception);
    insert(list, A_async);
    insert(list, A_struct);
    insert(list, A_return);
    insert(list, A_throw);
    insert(list, A_number);
    insert(list, A_keyword);
    insert(list, A_colon);
    insert(list, A_semicolon);
    insert(list, A_dot);
    insert(list, A_assign);
    insert(list, A_end_of_file);

    return list;
}

